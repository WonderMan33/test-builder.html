<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Golden Radio Hour – 12-Hour Stream Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #06060c;
      color: #f5f5f5;
      margin: 0;
      padding: 1.5rem;
    }
    h1 {
      margin-top: 0;
      font-size: 1.8rem;
    }
    h2 {
      font-size: 1.2rem;
      margin: 0 0 0.6rem 0;
    }
    .panel {
      background: #121221;
      border-radius: 10px;
      padding: 1rem 1.25rem;
      margin-bottom: 1rem;
      border: 1px solid #25253a;
    }
    label {
      display: block;
      margin: 0.4rem 0 0.2rem;
      font-size: 0.9rem;
      color: #d0d0e0;
    }
    input[type="text"] {
      width: 100%;
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      border: 1px solid #343450;
      background: #0b0b15;
      color: #f5f5f5;
      font-size: 0.95rem;
    }
    input[type="checkbox"] {
      accent-color: #ffc53a;
    }
    button {
      padding: 0.45rem 0.9rem;
      border-radius: 999px;
      border: 1px solid #ffc53a;
      background: #ffc53a;
      color: #111;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
      margin-right: 0.4rem;
      margin-top: 0.4rem;
    }
    button.secondary {
      background: transparent;
      color: #ffc53a;
    }
    button:hover {
      background: #ffdd74;
      color: #111;
    }
    button.secondary:hover {
      background: rgba(255, 197, 58, 0.1);
    }
    .small {
      font-size: 0.8rem;
      color: #a0a0b8;
      margin-top: 0.3rem;
    }
    .error {
      color: #ff8383;
      font-size: 0.85rem;
      margin-top: 0.3rem;
    }
    .success {
      color: #7fe29b;
      font-size: 0.85rem;
      margin-top: 0.3rem;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .col {
      flex: 1 1 260px;
      min-width: 260px;
    }
    .pill {
      display: inline-block;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: #25253a;
      font-size: 0.75rem;
      margin: 0 0.2rem 0.2rem 0;
    }
    .genre-list, .show-list {
      max-height: 220px;
      overflow-y: auto;
      border-radius: 8px;
      border: 1px solid #25253a;
      padding: 0.5rem;
      background: #0b0b15;
      font-size: 0.85rem;
    }
    .genre-item, .show-item {
      display: flex;
      align-items: center;
      margin-bottom: 0.25rem;
    }
    .genre-item label, .show-item label {
      margin: 0 0 0 0.35rem;
      font-size: 0.85rem;
      cursor: pointer;
    }
    .show-item small {
      color: #8080a0;
      margin-left: 0.25rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #25253a;
      padding: 0.4rem 0.6rem;
      text-align: left;
    }
    th {
      background: #19192a;
    }
    a {
      color: #7fd2ff;
    }
    tr[data-index] {
      cursor: move;
    }
    tr.drag-over {
      outline: 2px dashed #ffc53a;
    }
    #charCounter {
      font-size: 0.8rem;
      color: #a0a0b8;
      text-align: right;
      margin-top: 0.1rem;
    }
    @media (max-width: 720px) {
      body {
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  <h1>Golden Radio Hour – 12-Hour Stream Builder</h1>

  <div class="panel">
    <h2>1. Listener & Stream Info</h2>
    <div class="row">
      <div class="col">
        <label for="listenerName">Listener name</label>
        <input id="listenerName" type="text" placeholder="How should we refer to you?" />
      </div>
      <div class="col">
        <label for="streamTitle">Desired stream title (max 100 characters)</label>
        <input id="streamTitle" type="text" maxlength="100" placeholder="Example: Gunsmoke & Suspense: Night on the Frontier" />
        <div id="charCounter">0 / 100</div>
      </div>
    </div>
    <div class="small">
      This builder will aim for a single playlist of about 12 hours. You can reorder episodes after it’s generated.
    </div>
  </div>

  <div class="panel">
    <h2>2. Choose Genres & Shows</h2>
    <div class="row">
      <div class="col">
        <label>Filter by genres (optional)</label>
        <div id="genreList" class="genre-list">
          <!-- Genres will be injected here -->
        </div>
        <div class="small">
          Selecting genres narrows the show list on the right. You can still manually pick individual shows.
        </div>
      </div>
      <div class="col">
        <label for="showSearch">Search shows</label>
        <input id="showSearch" type="text" placeholder="Search by show name or tag…" />

        <label style="margin-top:0.4rem;">Pick your shows</label>
        <div id="showList" class="show-list">
          <!-- Shows with checkboxes injected here -->
        </div>
        <div class="small">
          You can select as many shows as you like. The builder will alternate episodes from the selected shows.
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2>3. Build Playlist (~12 hours)</h2>
    <button id="buildBtn">Generate 12-Hour Playlist</button>
    <button id="clearBtn" class="secondary">Clear playlist</button>
    <div id="status" class="small"></div>
    <div id="summary" class="small"></div>
    <div id="downloadWrapper" style="margin-top:0.5rem; display:none;">
      <a id="downloadM3U" href="#" download="golden_radio_hour_playlist.m3u">⬇ Download .m3u playlist</a>
    </div>
  </div>

  <div class="panel">
    <h2>4. Playlist (drag to reorder)</h2>
    <div id="playlistContainer" class="small">No playlist generated yet.</div>
  </div>

  <div class="panel">
    <h2>5. Send to Golden Radio Hour</h2>
    <div class="small">
      When you’re happy with the order, send it so it can be considered for a future stream.
    </div>
    <button id="sendBtn">Send playlist to Wade</button>
    <div id="submitStatus" class="small"></div>
  </div>

  <script>
    // Formspree endpoint wired to your form
    const FORMSPREE_ENDPOINT = "https://formspree.io/f/mqarbnyg";

    const MAX_HOURS = 11 + 50 / 60;
    const MAX_SECONDS = 11 * 3600 + 50 * 60;

    let allShows = [];
    let filteredShows = [];
    let currentPlaylist = [];

    const listenerNameInput = document.getElementById('listenerName');
    const streamTitleInput = document.getElementById('streamTitle');
    const charCounter = document.getElementById('charCounter');

    const genreListEl = document.getElementById('genreList');
    const showSearchInput = document.getElementById('showSearch');
    const showListEl = document.getElementById('showList');

    const buildBtn = document.getElementById('buildBtn');
    const clearBtn = document.getElementById('clearBtn');
    const sendBtn = document.getElementById('sendBtn');

    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');
    const playlistContainer = document.getElementById('playlistContainer');
    const downloadWrapper = document.getElementById('downloadWrapper');
    const downloadM3U = document.getElementById('downloadM3U');
    const submitStatusEl = document.getElementById('submitStatus');

    // Title char counter
    streamTitleInput.addEventListener('input', () => {
      const len = streamTitleInput.value.length;
      charCounter.textContent = `${len} / 100`;
    });

    // Load shows.json
    async function loadShows() {
      try {
        statusEl.textContent = 'Loading shows…';
        const res = await fetch('shows.json');
        if (!res.ok) throw new Error('Failed to load shows.json');
        allShows = await res.json();
        filteredShows = allShows.slice();
        buildGenreList();
        renderShowList();
        statusEl.textContent = `Loaded ${allShows.length} shows.`;
      } catch (err) {
        console.error(err);
        statusEl.className = 'error';
        statusEl.textContent = 'Error loading shows.json. Make sure it exists in the same folder.';
      }
    }

    function buildGenreList() {
      const genres = new Set();
      allShows.forEach(show => {
        (show.genres || []).forEach(g => {
          if (g && typeof g === 'string') genres.add(g.trim());
        });
      });
      const sortedGenres = Array.from(genres).sort();
      genreListEl.innerHTML = '';
      sortedGenres.forEach(g => {
        const id = `genre_${g.replace(/\s+/g, '_').toLowerCase()}`;
        const div = document.createElement('div');
        div.className = 'genre-item';
        div.innerHTML = `
          <input type="checkbox" id="${id}" data-genre="${g}">
          <label for="${id}">${g}</label>
        `;
        genreListEl.appendChild(div);
      });

      genreListEl.addEventListener('change', applyFilters);
    }

    function getSelectedGenres() {
      const checked = genreListEl.querySelectorAll('input[type="checkbox"]:checked');
      return Array.from(checked).map(cb => cb.getAttribute('data-genre'));
    }

    function applyFilters() {
      const selectedGenres = getSelectedGenres();
      const q = (showSearchInput.value || '').toLowerCase().trim();

      filteredShows = allShows.filter(show => {
        let ok = true;

        if (selectedGenres.length > 0) {
          const showGenres = (show.genres || []).map(g => (g || '').toLowerCase());
          const hit = selectedGenres.some(g => showGenres.includes(g.toLowerCase()));
          if (!hit) ok = false;
        }

        if (ok && q) {
          const tagsText = (show.tags || []).join(' ');
          const hay = (show.name + ' ' + tagsText).toLowerCase();
          if (!hay.includes(q)) ok = false;
        }

        return ok;
      });

      renderShowList();
    }

    showSearchInput.addEventListener('input', applyFilters);

    function renderShowList() {
      showListEl.innerHTML = '';
      if (filteredShows.length === 0) {
        showListEl.innerHTML = '<div class="small">No shows match your filters.</div>';
        return;
      }

      filteredShows.forEach(show => {
        const id = `show_${show.id}`;
        const tags = show.tags || [];
        const genres = show.genres || [];
        const div = document.createElement('div');
        div.className = 'show-item';
        let metaBits = [];
        if (genres.length) metaBits.push(genres.join(', '));
        if (tags.length) metaBits.push(tags.slice(0, 3).join(', '));
        const metaText = metaBits.length ? ` – ${metaBits.join(' · ')}` : '';

        div.innerHTML = `
          <input type="checkbox" id="${id}" data-show-id="${show.id}">
          <label for="${id}">${show.name}</label>
          <small>${metaText}</small>
        `;
        showListEl.appendChild(div);
      });
    }

    function getSelectedShowIds() {
      const checked = showListEl.querySelectorAll('input[type="checkbox"]:checked');
      return Array.from(checked).map(cb => cb.getAttribute('data-show-id'));
    }

    // Helpers for episodes / playlist

    function isMultiPartTitle(rawTitle) {
      if (!rawTitle) return false;
      const t = rawTitle.toLowerCase();
      const patterns = [
        'part 1',
        'part one',
        'pt 1',
        'pt. 1',
        'episode 1 of',
        'ep 1 of',
        '1 of 2',
        '1 of 3',
        'part i'
      ];
      return patterns.some(p => t.includes(p));
    }

    function normalizeTitle(raw, url) {
      let s = raw && raw.trim() ? raw.trim() : deriveTitleFromUrl(url);
      s = s.replace(/\.[a-z0-9]{2,4}$/i, '');
      s = s.replace(/[_\-]+/g, ' ');
      s = s.replace(/\s+/g, ' ').trim();
      s = s.split(' ').map(word => {
        if (word.toUpperCase() === word && word.length > 1) return word;
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      }).join(' ');
      return s;
    }

    function deriveTitleFromUrl(url) {
      if (!url) return 'Untitled Episode';
      try {
        const u = new URL(url);
        const path = u.pathname.split('/').pop() || '';
        return path || 'Untitled Episode';
      } catch {
        const parts = url.split('/');
        return parts.pop() || 'Untitled Episode';
      }
    }

    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function sumDurations(list) {
      return list.reduce((acc, ep) => acc + (ep.durationSeconds || 0), 0);
    }

    function formatDuration(seconds) {
      if (!seconds || seconds <= 0) return '–';
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = seconds % 60;
      const parts = [];
      if (h > 0) parts.push(`${h}h`);
      if (m > 0) parts.push(`${m}m`);
      if (h === 0 && m === 0) parts.push(`${s}s`);
      return parts.join(' ');
    }

    function buildAlternatingByDuration(grouped, targetSeconds) {
      const queues = grouped.map(g => g.slice());
      const result = [];
      let totalSeconds = 0;

      while (true) {
        let madeProgress = false;
        for (let i = 0; i < queues.length; i++) {
          const q = queues[i];
          if (q.length === 0) continue;
          const next = q[0];
          const d = next.durationSeconds || 0;

          if (d <= 0) {
            if (totalSeconds >= targetSeconds && result.length > 0) {
              continue;
            }
            result.push(q.shift());
            madeProgress = true;
          } else {
            if (totalSeconds + d > targetSeconds && result.length > 0) {
              continue;
            }
            result.push(q.shift());
            totalSeconds += d;
            madeProgress = true;
          }
        }
        if (!madeProgress) break;
        if (totalSeconds >= targetSeconds) break;
      }

      return { list: result, totalSeconds };
    }

    function buildAlternatingByCount(grouped, targetCount) {
      const queues = grouped.map(g => g.slice());
      const result = [];
      let added = 0;
      while (added < targetCount) {
        let madeProgress = false;
        for (let i = 0; i < queues.length && added < targetCount; i++) {
          if (queues[i].length > 0) {
            result.push(queues[i].shift());
            added++;
            madeProgress = true;
          }
        }
        if (!madeProgress) break;
      }
      return result;
    }

    function renderPlaylist(list, totalSeconds) {
      if (!list || list.length === 0) {
        playlistContainer.innerHTML = '<div class="small">No playlist generated yet.</div>';
        summaryEl.textContent = '';
        downloadWrapper.style.display = 'none';
        return;
      }

      const totalH = totalSeconds > 0 ? (totalSeconds / 3600).toFixed(2) : '–';
      let summaryText = `Episodes: ${list.length}`;
      if (totalSeconds > 0) {
        summaryText += ` • Approx duration: ${totalH} hours (target ~11h50m)`;
      } else {
        summaryText += ` • Approx 12-hour set (no duration data, using episode count).`;
      }
      summaryEl.textContent = summaryText;

      let html = '<table>';
      html += '<thead><tr><th>#</th><th>Show</th><th>Title</th><th>Duration</th><th>Link</th></tr></thead><tbody>';
      list.forEach((ep, idx) => {
        html += `<tr data-index="${idx}" draggable="true">
          <td>${idx + 1}</td>
          <td>${ep.showName}</td>
          <td>${ep.title}</td>
          <td>${formatDuration(ep.durationSeconds)}</td>
          <td><a href="${ep.url}" target="_blank" rel="noopener">Play</a></td>
        </tr>`;
      });
      html += '</tbody></table>';
      playlistContainer.innerHTML = html;

      attachDragAndDropHandlers();
      createM3UDownload(list);
    }

    function createM3UDownload(list) {
      if (!list || list.length === 0) {
        downloadWrapper.style.display = 'none';
        return;
      }

      let m3u = '#EXTM3U\n';
      list.forEach(ep => {
        const dur = ep.durationSeconds != null ? ep.durationSeconds : -1;
        m3u += `#EXTINF:${dur},${ep.showName} - ${ep.title}\n`;
        m3u += `${ep.url}\n`;
      });

      const blob = new Blob([m3u], { type: 'audio/x-mpegurl' });
      const url = URL.createObjectURL(blob);
      downloadM3U.href = url;
      downloadWrapper.style.display = 'block';
    }

    function attachDragAndDropHandlers() {
      const rows = playlistContainer.querySelectorAll('tr[data-index]');
      let dragSrcIndex = null;

      rows.forEach(row => {
        row.addEventListener('dragstart', (e) => {
          dragSrcIndex = parseInt(row.getAttribute('data-index'), 10);
          e.dataTransfer.effectAllowed = 'move';
        });

        row.addEventListener('dragover', (e) => {
          e.preventDefault();
          row.classList.add('drag-over');
          e.dataTransfer.dropEffect = 'move';
        });

        row.addEventListener('dragleave', () => {
          row.classList.remove('drag-over');
        });

        row.addEventListener('drop', (e) => {
          e.preventDefault();
          row.classList.remove('drag-over');
          const targetIndex = parseInt(row.getAttribute('data-index'), 10);
          if (dragSrcIndex === null || targetIndex === dragSrcIndex) return;

          const moved = currentPlaylist.splice(dragSrcIndex, 1)[0];
          currentPlaylist.splice(targetIndex, 0, moved);

          const totalSeconds = sumDurations(currentPlaylist);
          renderPlaylist(currentPlaylist, totalSeconds);
        });
      });
    }

    buildBtn.addEventListener('click', () => {
      submitStatusEl.textContent = '';
      submitStatusEl.className = 'small';

      const listener = listenerNameInput.value.trim();
      const title = streamTitleInput.value.trim();
      const selectedShowIds = getSelectedShowIds();

      if (!listener) {
        statusEl.className = 'error';
        statusEl.textContent = 'Please enter your listener name.';
        return;
      }
      if (!title) {
        statusEl.className = 'error';
        statusEl.textContent = 'Please enter a desired stream title.';
        return;
      }
      if (selectedShowIds.length === 0) {
        statusEl.className = 'error';
        statusEl.textContent = 'Please select at least one show.';
        return;
      }

      statusEl.className = 'small';
      statusEl.textContent = 'Building playlist…';

      const selectedShows = allShows.filter(s => selectedShowIds.includes(s.id));

      const grouped = selectedShows.map(show => {
        const eps = Array.isArray(show.episodes) ? show.episodes : [];
        let list = eps
          .map(ep => {
            const url = ep.url;
            const cleanedTitle = normalizeTitle(ep.title, url);
            return {
              showId: show.id,
              showName: show.name,
              title: cleanedTitle,
              url,
              durationSeconds: typeof ep.durationSeconds === 'number' ? ep.durationSeconds : null
            };
          })
          .filter(ep => ep.url && !isMultiPartTitle(ep.title));

        list = shuffleArray(list);
        return list;
      });

      const totalAvailableEpisodes = grouped.reduce((acc, g) => acc + g.length, 0);
      if (totalAvailableEpisodes === 0) {
        statusEl.className = 'error';
        statusEl.textContent = 'No eligible episodes found for the selected shows.';
        return;
      }

      const hasDurations = grouped.some(g => g.some(ep => ep.durationSeconds));
      let resultList, totalSeconds;

      if (hasDurations) {
        const result = buildAlternatingByDuration(grouped, MAX_SECONDS);
        resultList = result.list;
        totalSeconds = result.totalSeconds;
      } else {
        const approxCount = 24; // rough ~12-hour set if episodes ~30 min
        resultList = buildAlternatingByCount(grouped, approxCount);
        totalSeconds = sumDurations(resultList);
      }

      currentPlaylist = resultList.slice();
      renderPlaylist(currentPlaylist, totalSeconds);

      statusEl.className = 'success';
      statusEl.textContent = `Playlist created with ${currentPlaylist.length} episodes. You can drag rows to adjust the order.`;
    });

    clearBtn.addEventListener('click', () => {
      currentPlaylist = [];
      renderPlaylist([], 0);
      statusEl.className = 'small';
      statusEl.textContent = 'Playlist cleared.';
      submitStatusEl.textContent = '';
      submitStatusEl.className = 'small';
    });

    sendBtn.addEventListener('click', async () => {
      submitStatusEl.className = 'small';
      submitStatusEl.textContent = '';

      const listener = listenerNameInput.value.trim();
      const title = streamTitleInput.value.trim();

      if (!listener || !title) {
        submitStatusEl.className = 'error';
        submitStatusEl.textContent = 'Please enter your name and desired stream title before sending.';
        return;
      }

      if (!currentPlaylist || currentPlaylist.length === 0) {
        submitStatusEl.className = 'error';
        submitStatusEl.textContent = 'Please generate a playlist before sending.';
        return;
      }

      if (!FORMSPREE_ENDPOINT) {
        submitStatusEl.className = 'error';
        submitStatusEl.textContent = 'Formspree endpoint is not configured.';
        return;
      }

      const payload = {
        listener,
        streamTitle: title,
        episodeCount: currentPlaylist.length,
        playlist: currentPlaylist.map((ep, idx) => ({
          index: idx + 1,
          show: ep.showName,
          title: ep.title,
          url: ep.url,
          durationSeconds: ep.durationSeconds || null
        }))
      };

      submitStatusEl.textContent = 'Sending playlist…';

      try {
        const res = await fetch(FORMSPREE_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          throw new Error('Non-200 response');
        }

        submitStatusEl.className = 'success';
        submitStatusEl.textContent = 'Playlist sent successfully. Thank you!';
      } catch (err) {
        console.error(err);
        submitStatusEl.className = 'error';
        submitStatusEl.textContent = 'There was a problem sending the playlist. Please try again later.';
      }
    });

    loadShows();
  </script>
</body>
</html>
