<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Golden Radio Hour – Playlist Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b0b10;
      color: #f5f5f5;
      margin: 0;
      padding: 1.5rem;
    }
    h1 {
      margin-top: 0;
      font-size: 1.8rem;
    }
    .panel {
      background: #151521;
      border-radius: 10px;
      padding: 1rem 1.25rem;
      margin-bottom: 1rem;
      border: 1px solid #26263a;
    }
    label {
      display: block;
      margin: 0.4rem 0 0.2rem;
      font-size: 0.9rem;
      color: #d0d0e0;
    }
    select, input[type="number"], input[type="text"], button {
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      border: 1px solid #343450;
      background: #101019;
      color: #f5f5f5;
      font-size: 0.95rem;
    }
    select[multiple] {
      height: 160px;
    }
    button {
      cursor: pointer;
      border: 1px solid #ffd35a;
      background: #ffc53a;
      color: #111;
      font-weight: 600;
      margin-top: 0.75rem;
    }
    button:hover {
      background: #ffdd74;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .col {
      flex: 1 1 260px;
      min-width: 260px;
    }
    .small {
      font-size: 0.8rem;
      color: #a0a0b8;
      margin-top: 0.3rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #26263a;
      padding: 0.4rem 0.6rem;
      text-align: left;
    }
    th {
      background: #1d1d2b;
    }
    a {
      color: #7fd2ff;
    }
    .error {
      color: #ff7676;
      font-size: 0.85rem;
      margin-top: 0.4rem;
    }
    .success {
      color: #7fe29b;
      font-size: 0.85rem;
      margin-top: 0.4rem;
    }
    .pill-toggle {
      display: inline-flex;
      border-radius: 999px;
      border: 1px solid #343450;
      overflow: hidden;
      margin-top: 0.3rem;
    }
    .pill-toggle button {
      border-radius: 0;
      border: none;
      background: transparent;
      padding: 0.35rem 0.7rem;
      font-size: 0.85rem;
      color: #d0d0e0;
    }
    .pill-toggle button.active {
      background: #ffc53a;
      color: #111;
    }
    tr[data-index] {
      cursor: move;
    }
    tr.drag-over {
      outline: 2px dashed #ffc53a;
    }
    .badge {
      display: inline-block;
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      background: #26263a;
      font-size: 0.75rem;
      margin: 0 0.2rem 0.2rem 0;
    }
    #showDetailsTitle {
      font-weight: 600;
      margin-bottom: 0.3rem;
    }
    #showDetailsDesc {
      font-size: 0.85rem;
      color: #d0d0e0;
      margin-bottom: 0.3rem;
    }
    @media (max-width: 700px) {
      body {
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  <h1>Golden Radio Hour – Playlist Builder</h1>

  <div class="panel">
    <div class="row">
      <div class="col">
        <label for="genreFilter">Filter by genre</label>
        <select id="genreFilter">
          <option value="">All genres</option>
        </select>

        <label for="showSearch">Search shows / tags</label>
        <input id="showSearch" type="text" placeholder="e.g. western, comedy, mystery" />

        <label for="showSelect" style="margin-top:0.6rem;">Shows</label>
        <select id="showSelect" multiple></select>
        <div class="small">
          Hold Ctrl (Cmd on Mac) to select multiple shows. Episodes will be alternated evenly.
        </div>
      </div>

      <div class="col">
        <label>Mode</label>
        <div class="pill-toggle">
          <button type="button" id="modeEpisodes" class="active">By Episodes</button>
          <button type="button" id="modeHours">By Hours (max 11h50)</button>
        </div>

        <div id="episodesConfig">
          <label for="episodeCount">Number of episodes</label>
          <input type="number" id="episodeCount" min="1" value="20" />
        </div>

        <div id="hoursConfig" style="display:none;">
          <label for="targetHours">Target duration (hours)</label>
          <input type="number" id="targetHours" min="1" max="11.83" step="0.25" value="11.83" />
          <div class="small">
            Capped at 11h 50m (11.83 hours). Requires <code>durationSeconds</code> in JSON.
          </div>
        </div>

        <label style="margin-top:0.4rem;">
          <input type="checkbox" id="shuffleToggle" checked />
          Shuffle inside each show before alternating
        </label>
        <div class="small">
          Multipart episodes (Part 1, Pt. 1, 1 of 2, etc.) are automatically skipped.
        </div>

        <label style="margin-top:0.6rem;">Build Playlist</label>
        <button id="buildBtn">Build Playlist</button>
        <div id="status" class="small"></div>
        <div id="downloadWrapper" style="margin-top:0.4rem; display:none;">
          <a id="downloadM3U" href="#" download="grh_playlist.m3u">⬇ Download .m3u playlist</a>
        </div>
      </div>

      <div class="col">
        <label>Show details</label>
        <div id="showDetails" class="small">
          <div>No show selected.</div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2 style="margin-top:0;">Generated Playlist (drag to reorder)</h2>
    <div id="summary" class="small"></div>
    <div id="playlistContainer"></div>
  </div>

  <script>
    const MAX_HOURS = 11 + 50 / 60;
    const MAX_SECONDS = 11 * 3600 + 50 * 60;

    const showSelect = document.getElementById('showSelect');
    const genreFilter = document.getElementById('genreFilter');
    const showSearch = document.getElementById('showSearch');

    const modeEpisodesBtn = document.getElementById('modeEpisodes');
    const modeHoursBtn = document.getElementById('modeHours');
    const episodesConfig = document.getElementById('episodesConfig');
    const hoursConfig = document.getElementById('hoursConfig');
    const episodeCountInput = document.getElementById('episodeCount');
    const targetHoursInput = document.getElementById('targetHours');
    const shuffleToggle = document.getElementById('shuffleToggle');
    const buildBtn = document.getElementById('buildBtn');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');
    const playlistContainer = document.getElementById('playlistContainer');
    const downloadWrapper = document.getElementById('downloadWrapper');
    const downloadM3U = document.getElementById('downloadM3U');
    const showDetails = document.getElementById('showDetails');

    let allShows = [];
    let filteredShows = [];
    let currentMode = 'episodes';
    let currentPlaylist = [];

    // MODE TOGGLE
    modeEpisodesBtn.addEventListener('click', () => {
      currentMode = 'episodes';
      modeEpisodesBtn.classList.add('active');
      modeHoursBtn.classList.remove('active');
      episodesConfig.style.display = '';
      hoursConfig.style.display = 'none';
    });

    modeHoursBtn.addEventListener('click', () => {
      currentMode = 'hours';
      modeHoursBtn.classList.add('active');
      modeEpisodesBtn.classList.remove('active');
      hoursConfig.style.display = '';
      episodesConfig.style.display = 'none';
    });

    // LOAD SHOWS
    async function loadShows() {
      try {
        statusEl.textContent = 'Loading shows.json...';
        const res = await fetch('shows.json');
        if (!res.ok) throw new Error('Failed to load shows.json');
        allShows = await res.json();
        filteredShows = allShows.slice();
        populateGenreFilter();
        renderShowOptions(false);
        statusEl.textContent = `Loaded ${allShows.length} shows.`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = '';
        const errDiv = document.createElement('div');
        errDiv.className = 'error';
        errDiv.textContent = 'Error loading shows.json – check that it exists and is valid JSON.';
        statusEl.parentElement.appendChild(errDiv);
      }
    }

    function populateGenreFilter() {
      const genres = new Set();
      allShows.forEach(show => {
        (show.genres || []).forEach(g => {
          if (g && typeof g === 'string') genres.add(g.trim());
        });
      });
      genreFilter.innerHTML = '<option value="">All genres</option>';
      Array.from(genres).sort().forEach(g => {
        const opt = document.createElement('option');
        opt.value = g;
        opt.textContent = g;
        genreFilter.appendChild(opt);
      });
    }

    function applyFilters() {
      const genre = genreFilter.value.trim().toLowerCase();
      const q = showSearch.value.trim().toLowerCase();

      filteredShows = allShows.filter(show => {
        let ok = true;

        if (genre) {
          const genres = (show.genres || []).map(g => (g || '').toLowerCase());
          ok = genres.includes(genre);
          if (!ok) return false;
        }

        if (q) {
          const tagsText = (show.tags || []).join(' ');
          const hay = (show.name + ' ' + tagsText).toLowerCase();
          ok = hay.includes(q);
        }

        return ok;
      });

      renderShowOptions(true);
    }

    function renderShowOptions(preserveSelection) {
      const prevSelected = preserveSelection
        ? Array.from(showSelect.selectedOptions).map(o => o.value)
        : [];

      showSelect.innerHTML = '';
      filteredShows.forEach(show => {
        const opt = document.createElement('option');
        opt.value = show.id;
        opt.textContent = show.name || show.id;
        if (prevSelected.includes(show.id)) {
          opt.selected = true;
        }
        showSelect.appendChild(opt);
      });

      updateShowDetails();
    }

    genreFilter.addEventListener('change', applyFilters);
    showSearch.addEventListener('input', applyFilters);
    showSelect.addEventListener('change', updateShowDetails);

    function updateShowDetails() {
      const selectedIds = Array.from(showSelect.selectedOptions).map(o => o.value);
      if (selectedIds.length === 0) {
        showDetails.innerHTML = '<div class="small">No show selected.</div>';
        return;
      }

      if (selectedIds.length > 1) {
        showDetails.innerHTML = `<div class="small">${selectedIds.length} shows selected.</div>`;
        return;
      }

      const showId = selectedIds[0];
      const show = allShows.find(s => s.id === showId);
      if (!show) {
        showDetails.innerHTML = '<div class="small">Show details not found.</div>';
        return;
      }

      const genres = show.genres || [];
      const tags = show.tags || [];
      const desc = show.description || '';

      let html = '';
      html += `<div id="showDetailsTitle">${show.name || show.id}</div>`;

      if (genres.length) {
        html += `<div class="small">Genres: `;
        genres.forEach(g => {
          html += `<span class="badge">${g}</span>`;
        });
        html += `</div>`;
      }

      if (tags.length) {
        html += `<div class="small">Tags: `;
        tags.forEach(t => {
          html += `<span class="badge">${t}</span>`;
        });
        html += `</div>`;
      }

      if (desc) {
        html += `<div id="showDetailsDesc">${desc}</div>`;
      }

      showDetails.innerHTML = html;
    }

    // TITLE / MULTIPART HELPERS
    function isMultiPartTitle(rawTitle) {
      if (!rawTitle) return false;
      const t = rawTitle.toLowerCase();
      const patterns = [
        'part 1',
        'part one',
        'pt 1',
        'pt. 1',
        'episode 1 of',
        'ep 1 of',
        '1 of 2',
        '1 of 3',
        'part i'
      ];
      return patterns.some(p => t.includes(p));
    }

    function normalizeTitle(raw, url) {
      let s = raw && raw.trim() ? raw.trim() : deriveTitleFromUrl(url);
      s = s.replace(/\.[a-z0-9]{2,4}$/i, '');
      s = s.replace(/[_\-]+/g, ' ');
      s = s.replace(/\s+/g, ' ').trim();
      s = s.split(' ').map(word => {
        if (word.toUpperCase() === word && word.length > 1) return word;
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      }).join(' ');
      return s;
    }

    function deriveTitleFromUrl(url) {
      if (!url) return 'Untitled Episode';
      try {
        const u = new URL(url);
        const path = u.pathname.split('/').pop() || '';
        return path || 'Untitled Episode';
      } catch {
        const parts = url.split('/');
        return parts.pop() || 'Untitled Episode';
      }
    }

    // BUILD PLAYLIST
    buildBtn.addEventListener('click', () => {
      try {
        const selectedShowIds = Array.from(showSelect.selectedOptions).map(o => o.value);
        if (selectedShowIds.length === 0) {
          statusEl.className = 'error';
          statusEl.textContent = 'Select at least one show.';
          return;
        }

        statusEl.className = 'small';
        statusEl.textContent = 'Building playlist...';

        const selectedShows = allShows.filter(s => selectedShowIds.includes(s.id));

        const grouped = selectedShows.map(show => {
          const eps = Array.isArray(show.episodes) ? show.episodes : [];
          let list = eps
            .map(ep => {
              const url = ep.url;
              const cleanedTitle = normalizeTitle(ep.title, url);
              return {
                showId: show.id,
                showName: show.name,
                title: cleanedTitle,
                url,
                durationSeconds: typeof ep.durationSeconds === 'number' ? ep.durationSeconds : null
              };
            })
            .filter(ep => ep.url && !isMultiPartTitle(ep.title));

          if (shuffleToggle.checked) {
            list = shuffleArray(list);
          }
          return list;
        });

        const totalAvailableEpisodes = grouped.reduce((acc, g) => acc + g.length, 0);
        if (totalAvailableEpisodes === 0) {
          statusEl.className = 'error';
          statusEl.textContent = 'No eligible episodes found (multipart titles may have been filtered out).';
          return;
        }

        let chosen = [];
        let totalSeconds = 0;

        if (currentMode === 'episodes') {
          const targetCount = Math.max(1, parseInt(episodeCountInput.value || '1', 10));
          chosen = buildAlternatingByCount(grouped, targetCount);
          totalSeconds = sumDurations(chosen);
        } else {
          let requestedHours = parseFloat(targetHoursInput.value || MAX_HOURS);
          if (isNaN(requestedHours)) requestedHours = MAX_HOURS;
          requestedHours = Math.min(requestedHours, MAX_HOURS);
          const targetSeconds = Math.min(requestedHours * 3600, MAX_SECONDS);

          const hasDurations = grouped.some(g => g.some(ep => ep.durationSeconds));
          if (!hasDurations) {
            const fallbackCount = Math.max(1, parseInt(episodeCountInput.value || '20', 10));
            chosen = buildAlternatingByCount(grouped, fallbackCount);
            totalSeconds = sumDurations(chosen);
          } else {
            const result = buildAlternatingByDuration(grouped, targetSeconds);
            chosen = result.list;
            totalSeconds = result.totalSeconds;
          }
        }

        currentPlaylist = chosen.slice();
        renderPlaylist(currentPlaylist, totalSeconds);
        createM3UDownload(currentPlaylist);

        statusEl.className = 'success';
        statusEl.textContent = `Playlist created with ${currentPlaylist.length} episodes.`;
      } catch (err) {
        console.error(err);
        statusEl.className = 'error';
        statusEl.textContent = 'Error building playlist – check console for details.';
      }
    });

    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function sumDurations(list) {
      return list.reduce((acc, ep) => acc + (ep.durationSeconds || 0), 0);
    }

    function formatDuration(seconds) {
      if (!seconds || seconds <= 0) return '–';
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = seconds % 60;
      const parts = [];
      if (h > 0) parts.push(`${h}h`);
      if (m > 0) parts.push(`${m}m`);
      if (h === 0 && m === 0) parts.push(`${s}s`);
      return parts.join(' ');
    }

    function buildAlternatingByCount(grouped, targetCount) {
      const queues = grouped.map(g => g.slice());
      const result = [];
      let added = 0;
      while (added < targetCount) {
        let madeProgress = false;
        for (let i = 0; i < queues.length && added < targetCount; i++) {
          if (queues[i].length > 0) {
            result.push(queues[i].shift());
            added++;
            madeProgress = true;
          }
        }
        if (!madeProgress) break;
      }
      return result;
    }

    function buildAlternatingByDuration(grouped, targetSeconds) {
      const queues = grouped.map(g => g.slice());
      const result = [];
      let totalSeconds = 0;
      while (true) {
        let madeProgress = false;
        for (let i = 0; i < queues.length; i++) {
          const q = queues[i];
          if (q.length === 0) continue;
          const next = q[0];
          const d = next.durationSeconds || 0;
          if (d <= 0) {
            if (totalSeconds >= targetSeconds && result.length > 0) {
              continue;
            }
            result.push(q.shift());
            madeProgress = true;
          } else {
            if (totalSeconds + d > targetSeconds && result.length > 0) {
              continue;
            }
            result.push(q.shift());
            totalSeconds += d;
            madeProgress = true;
          }
        }
        if (!madeProgress) break;
        if (totalSeconds >= targetSeconds) break;
      }
      return { list: result, totalSeconds };
    }

    function renderPlaylist(list, totalSeconds) {
      if (!list || list.length === 0) {
        playlistContainer.innerHTML = '<div class="small">No episodes selected.</div>';
        summaryEl.textContent = '';
        downloadWrapper.style.display = 'none';
        return;
      }

      const totalH = totalSeconds > 0 ? (totalSeconds / 3600).toFixed(2) : '–';
      summaryEl.textContent =
        `Episodes: ${list.length}` +
        (totalSeconds > 0 ? ` • Approx duration: ${totalH} hours (max 11h50m)` : '');

      let html = '<table>';
      html += '<thead><tr><th>#</th><th>Show</th><th>Title</th><th>Duration</th><th>Link</th></tr></thead><tbody>';
      list.forEach((ep, idx) => {
        html += `<tr data-index="${idx}" draggable="true">
          <td>${idx + 1}</td>
          <td>${ep.showName}</td>
          <td>${ep.title}</td>
          <td>${formatDuration(ep.durationSeconds)}</td>
          <td><a href="${ep.url}" target="_blank" rel="noopener">Play</a></td>
        </tr>`;
      });
      html += '</tbody></table>';
      playlistContainer.innerHTML = html;

      attachDragAndDropHandlers();
      downloadWrapper.style.display = 'block';
    }

    function createM3UDownload(list) {
      if (!list || list.length === 0) {
        downloadWrapper.style.display = 'none';
        return;
      }

      let m3u = '#EXTM3U\n';
      list.forEach(ep => {
        const dur = ep.durationSeconds != null ? ep.durationSeconds : -1;
        m3u += `#EXTINF:${dur},${ep.showName} - ${ep.title}\n`;
        m3u += `${ep.url}\n`;
      });

      const blob = new Blob([m3u], { type: 'audio/x-mpegurl' });
      const url = URL.createObjectURL(blob);
      downloadM3U.href = url;
      downloadWrapper.style.display = 'block';
    }

    function attachDragAndDropHandlers() {
      const rows = playlistContainer.querySelectorAll('tr[data-index]');
      let dragSrcIndex = null;

      rows.forEach(row => {
        row.addEventListener('dragstart', (e) => {
          dragSrcIndex = parseInt(row.getAttribute('data-index'), 10);
          e.dataTransfer.effectAllowed = 'move';
        });

        row.addEventListener('dragover', (e) => {
          e.preventDefault();
          row.classList.add('drag-over');
          e.dataTransfer.dropEffect = 'move';
        });

        row.addEventListener('dragleave', () => {
          row.classList.remove('drag-over');
        });

        row.addEventListener('drop', (e) => {
          e.preventDefault();
          row.classList.remove('drag-over');
          const targetIndex = parseInt(row.getAttribute('data-index'), 10);
          if (dragSrcIndex === null || targetIndex === dragSrcIndex) return;

          const moved = currentPlaylist.splice(dragSrcIndex, 1)[0];
          currentPlaylist.splice(targetIndex, 0, moved);

          const totalSeconds = sumDurations(currentPlaylist);
          renderPlaylist(currentPlaylist, totalSeconds);
          createM3UDownload(currentPlaylist);
        });
      });
    }

    loadShows();
  </script>
</body>
</html>
