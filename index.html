<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Golden Radio Hour – 12-Hour Stream Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #06060c;
      color: #f5f5f5;
      margin: 0;
      padding: 1.5rem;
    }
    h1 {
      margin-top: 0;
      font-size: 1.8rem;
    }
    h2 {
      font-size: 1.2rem;
      margin: 0 0 0.6rem 0;
    }
    .panel {
      background: #121221;
      border-radius: 10px;
      padding: 1rem 1.25rem;
      margin-bottom: 1rem;
      border: 1px solid #25253a;
    }
    label {
      display: block;
      margin: 0.4rem 0 0.2rem;
      font-size: 0.9rem;
      color: #d0d0e0;
    }
    input[type="text"] {
      width: 100%;
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      border: 1px solid #343450;
      background: #0b0b15;
      color: #f5f5f5;
      font-size: 0.95rem;
    }
    input[type="checkbox"],
    input[type="radio"] {
      accent-color: #ffc53a;
      cursor: pointer;
    }
    button {
      padding: 0.45rem 0.9rem;
      border-radius: 999px;
      border: 1px solid #ffc53a;
      background: #ffc53a;
      color: #111;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
      margin-right: 0.4rem;
      margin-top: 0.4rem;
    }
    button.secondary {
      background: transparent;
      color: #ffc53a;
    }
    button:hover {
      background: #ffdd74;
      color: #111;
    }
    button.secondary:hover {
      background: rgba(255, 197, 58, 0.1);
    }
    .small {
      font-size: 0.8rem;
      color: #a0a0b8;
      margin-top: 0.3rem;
    }
    .error {
      color: #ff8383;
      font-size: 0.85rem;
      margin-top: 0.3rem;
    }
    .success {
      color: #7fe29b;
      font-size: 0.85rem;
      margin-top: 0.3rem;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .col {
      flex: 1 1 260px;
      min-width: 260px;
    }
    .genre-list, .show-list {
      max-height: 220px;
      overflow-y: auto;
      border-radius: 8px;
      border: 1px solid #25253a;
      padding: 0.5rem;
      background: #0b0b15;
      font-size: 0.85rem;
    }
    .genre-item, .show-item {
      display: flex;
      align-items: center;
      margin-bottom: 0.25rem;
    }
    .genre-item label, .show-item label {
      margin: 0 0 0 0.35rem;
      font-size: 0.85rem;
      cursor: pointer;
    }
    .show-item small {
      color: #8080a0;
      margin-left: 0.25rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #25253a;
      padding: 0.4rem 0.6rem;
      text-align: left;
    }
    th {
      background: #19192a;
    }
    tr[data-index] {
      cursor: move;
    }
    tr.drag-over {
      outline: 2px dashed #ffc53a;
    }
    #charCounter {
      font-size: 0.8rem;
      color: #a0a0b8;
      text-align: right;
      margin-top: 0.1rem;
    }
    .mode-line {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.6rem;
      font-size: 0.9rem;
    }
    .mode-line label {
      display: flex;
      align-items: center;
      margin: 0;
      cursor: pointer;
      color: #e0e0ff;
    }
    .mode-line input[type="radio"] {
      margin-right: 0.3rem;
    }
    .mode-help {
      font-size: 0.8rem;
      color: #a0a0b8;
      margin-bottom: 0.4rem;
    }
    .disabled {
      opacity: 0.35;
      pointer-events: none;
    }
    .bg-options {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      margin-top: 0.1rem;
    }
    .bg-options label {
      display: flex;
      align-items: center;
      margin: 0;
      font-size: 0.85rem;
      color: #e0e0ff;
    }
    .bg-options input[type="radio"] {
      margin-right: 0.35rem;
    }
    @media (max-width: 720px) {
      body {
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  <h1>Golden Radio Hour – 12-Hour Stream Builder</h1>

  <div class="panel">
    <h2>1. Listener & Stream Info</h2>
    <div class="row">
      <div class="col">
        <label for="listenerName">Listener name</label>
        <input id="listenerName" type="text" placeholder="How should we refer to you?" />
      </div>
      <div class="col">
        <label for="streamTitle">Desired stream title (max 100 characters)</label>
        <input id="streamTitle" type="text" maxlength="100" placeholder="Example: Gunsmoke & Suspense: Night on the Frontier" />
        <div id="charCounter">0 / 100</div>
      </div>
    </div>
    <div class="row" style="margin-top:0.8rem;">
      <div class="col">
        <label>Background style</label>
        <div class="bg-options">
          <label><input type="radio" name="background" value="dark_screen" checked>Dark screen</label>
          <label><input type="radio" name="background" value="cozy_fireplace">Cozy fireplace</label>
          <label><input type="radio" name="background" value="dark_room">Dark room background</label>
        </div>
        <div class="small">This tells Wade what kind of visual mood you’d like behind the programs.</div>
      </div>
    </div>
    <div class="small">
      This builder will aim for a single playlist of about 12 hours (max ~11h50m). You can reorder episodes after it’s generated, and they’ll be sent in that order.
    </div>
  </div>

  <div class="panel">
    <h2>2. How Do You Want to Choose Shows?</h2>
    <div class="mode-line">
      <label>
        <input type="radio" name="selectionMode" value="genre" checked>
        Choose by genre
      </label>
      <label>
        <input type="radio" name="selectionMode" value="show">
        Choose specific shows
      </label>
    </div>
    <div class="mode-help" id="modeHelp">
      Genre mode is active: select one or more genres. All shows in those genres will be pooled.
    </div>

    <div class="row">
      <div class="col">
        <label>Genres</label>
        <div id="genreList" class="genre-list"></div>
        <div id="genreNote" class="small"></div>
      </div>
      <div class="col">
        <label>Shows</label>
        <div id="showList" class="show-list"></div>
        <div id="showHelpText" class="small">
          Genre mode: list is informational (all shows in the chosen genres are used).<br>
          Show mode: you’ll pick exact shows with checkboxes.
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2>3. Build Playlist (~12 hours)</h2>
    <button id="buildBtn">Generate 12-Hour Playlist</button>
    <button id="clearBtn" class="secondary">Clear playlist</button>
    <div id="status" class="small"></div>
    <div id="summary" class="small"></div>
  </div>

  <div class="panel">
    <h2>4. Playlist (drag to reorder)</h2>
    <div id="playlistContainer" class="small">No playlist generated yet.</div>
  </div>

  <div class="panel">
    <h2>5. Send to Golden Radio Hour</h2>
    <div class="small">
      When you’re happy with the order, send it so it can be considered for a future stream.
    </div>
    <button id="sendBtn">Send playlist to Wade</button>
    <div id="submitStatus" class="small"></div>
  </div>

  <script>
    const FORMSPREE_ENDPOINT = "https://formspree.io/f/mqarbnyg";
    const MAX_SECONDS = 11 * 3600 + 50 * 60; // 11h50m

    let allShows = [];          // [{id, name, genres, tags, description, episodes: [...] }]
    let currentPlaylist = [];
    let selectionMode = "genre";
    let genresAvailable = false;

    const listenerNameInput = document.getElementById('listenerName');
    const streamTitleInput = document.getElementById('streamTitle');
    const charCounter = document.getElementById('charCounter');

    const genreListEl = document.getElementById('genreList');
    const showListEl = document.getElementById('showList');
    const genreNoteEl = document.getElementById('genreNote');
    const modeHelpEl = document.getElementById('modeHelp');
    const showHelpText = document.getElementById('showHelpText');

    const buildBtn = document.getElementById('buildBtn');
    const clearBtn = document.getElementById('clearBtn');
    const sendBtn = document.getElementById('sendBtn');

    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');
    const playlistContainer = document.getElementById('playlistContainer');
    const submitStatusEl = document.getElementById('submitStatus');

    streamTitleInput.addEventListener('input', () => {
      const len = streamTitleInput.value.length;
      charCounter.textContent = `${len} / 100`;
    });

    document.querySelectorAll('input[name="selectionMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        selectionMode = radio.value;
        onSelectionModeChange();
      });
    });

    function slugify(str) {
      return String(str || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '') || 'show-' + Math.random().toString(36).slice(2, 8);
    }

    function formatDuration(seconds) {
      if (!seconds || seconds <= 0) return '–';
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = seconds % 60;
      const parts = [];
      if (h > 0) parts.push(`${h}h`);
      if (m > 0) parts.push(`${m}m`);
      if (h === 0 && m === 0) parts.push(`${s}s`);
      return parts.join(' ');
    }

    function sumDurations(list) {
      return list.reduce((acc, ep) => acc + (ep.durationSeconds || 0), 0);
    }

    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function isMultiPartTitle(rawTitle) {
      if (!rawTitle) return false;
      const t = rawTitle.toLowerCase();
      const patterns = [
        'part 1', 'part one', 'pt 1', 'pt. 1',
        'episode 1 of', 'ep 1 of',
        '1 of 2', '1 of 3', 'part i'
      ];
      return patterns.some(p => t.includes(p));
    }

    function buildAlternatingByDuration(grouped, targetSeconds) {
      const queues = grouped.map(g => g.slice());
      const result = [];
      let totalSeconds = 0;

      while (true) {
        let madeProgress = false;
        for (let i = 0; i < queues.length; i++) {
          const q = queues[i];
          if (!q.length) continue;
          const next = q[0];
          const d = next.durationSeconds || 0;

          if (d <= 0) {
            result.push(q.shift());
            madeProgress = true;
          } else {
            if (totalSeconds + d > targetSeconds && result.length > 0) {
              continue;
            }
            result.push(q.shift());
            totalSeconds += d;
            madeProgress = true;
          }
        }
        if (!madeProgress) break;
        if (totalSeconds >= targetSeconds) break;
      }
      return { list: result, totalSeconds };
    }

    function buildAlternatingByCount(grouped, targetCount) {
      const queues = grouped.map(g => g.slice());
      const result = [];
      let added = 0;
      while (added < targetCount) {
        let madeProgress = false;
        for (let i = 0; i < queues.length && added < targetCount; i++) {
          if (queues[i].length > 0) {
            result.push(queues[i].shift());
            added++;
            madeProgress = true;
          }
        }
        if (!madeProgress) break;
      }
      return result;
    }

    function getBackgroundChoice() {
      const r = document.querySelector('input[name="background"]:checked');
      return r ? r.value : null;
    }

    function normalizeFromFlatJson(data) {
      // data is array of per-file entries from your enriched builder:
      // { show, title, displayTitle, relativePath, url, durationSeconds, genre, tags, description }
      const arr = Array.isArray(data) ? data : [];

      const map = new Map(); // showName -> showObj

      arr.forEach((item, idx) => {
        if (!item || !item.url) return;

        const showName = item.show || (item.relativePath ? item.relativePath.split('/')[0] : `Show ${idx+1}`);
        const showId = slugify(showName);

        if (!map.has(showName)) {
          let genre = item.genre || 'Unknown';
          let tags = item.tags || [];
          if (typeof tags === 'string') tags = [tags];
          if (!Array.isArray(tags)) tags = [];

          const description = item.description || '';

          map.set(showName, {
            id: showId,
            name: showName,
            genres: genre ? [genre] : [],
            tags,
            description,
            episodes: []
          });
        }

        const showObj = map.get(showName);

        const epTitle = item.displayTitle || item.title || 'Untitled Episode';
        const ep = {
          title: epTitle,
          url: item.url,
          durationSeconds: typeof item.durationSeconds === 'number' ? item.durationSeconds : null
        };

        showObj.episodes.push(ep);
      });

      return Array.from(map.values());
    }

    async function loadShows() {
      try {
        statusEl.textContent = 'Loading shows…';

        const res = await fetch('./shows.json?cachebust=' + Date.now());
        if (!res.ok) {
          throw new Error('HTTP ' + res.status + ' when fetching shows.json');
        }
        const text = await res.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch (e) {
          console.error('JSON parse error:', e);
          throw new Error('JSON parse error – shows.json is not valid JSON');
        }

        // We assume flat per-file JSON from the enriched builder
        allShows = normalizeFromFlatJson(data);

        if (!allShows.length) {
          throw new Error('No shows found in shows.json.');
        }

        const anyGenres = allShows.some(s => (s.genres || []).length > 0);
        genresAvailable = anyGenres;

        if (!genresAvailable) {
          genreListEl.innerHTML = '<div class="small">No genres found in this JSON.</div>';
          genreNoteEl.textContent = 'Genre mode will not be very useful with this file. You can still choose shows manually.';
          document.querySelector('input[name="selectionMode"][value="show"]').checked = true;
          selectionMode = 'show';
          onSelectionModeChange(true);
        } else {
          buildGenreList();
          genreNoteEl.textContent = '';
        }

        renderShowList();
        statusEl.className = 'small';
        statusEl.textContent = `Loaded ${allShows.length} shows.`;
      } catch (err) {
        console.error('loadShows error:', err);
        statusEl.className = 'error';
        statusEl.textContent = 'Error loading shows.json: ' + err.message;
      }
    }

    function buildGenreList() {
      const genres = new Set();
      allShows.forEach(show => {
        (show.genres || []).forEach(g => {
          if (g && typeof g === 'string') genres.add(g.trim());
        });
      });
      const sortedGenres = Array.from(genres).sort();
      genreListEl.innerHTML = '';
      if (!sortedGenres.length) {
        genreListEl.innerHTML = '<div class="small">No genres found in this JSON.</div>';
        return;
      }
      sortedGenres.forEach(g => {
        const id = `genre_${g.replace(/\s+/g, '_').toLowerCase()}`;
        const div = document.createElement('div');
        div.className = 'genre-item';
        div.innerHTML = `
          <input type="checkbox" id="${id}" data-genre="${g}">
          <label for="${id}">${g}</label>
        `;
        genreListEl.appendChild(div);
      });

      genreListEl.addEventListener('change', () => {
        if (selectionMode === "genre") {
          renderShowList();
        }
      });
    }

    function getSelectedGenres() {
      const checked = genreListEl.querySelectorAll('input[type="checkbox"]:checked');
      return Array.from(checked).map(cb => cb.getAttribute('data-genre'));
    }

    function getShowsMatchingSelectedGenres() {
      if (!genresAvailable) return allShows.slice();
      const selectedGenres = getSelectedGenres();
      if (selectedGenres.length === 0) {
        return allShows.slice();
      }
      return allShows.filter(show => {
        const showGenres = (show.genres || []).map(g => (g || '').toLowerCase());
        return selectedGenres.some(g => showGenres.includes(g.toLowerCase()));
      });
    }

    function renderShowList() {
      showListEl.innerHTML = '';

      let showsToRender;
      if (selectionMode === "genre") {
        showsToRender = getShowsMatchingSelectedGenres();
      } else {
        showsToRender = allShows.slice();
      }

      if (!showsToRender.length) {
        showListEl.innerHTML = '<div class="small">No shows to display.</div>';
        return;
      }

      showsToRender.forEach(show => {
        const id = `show_${show.id}`;
        const tags = show.tags || [];
        const genres = show.genres || [];
        const div = document.createElement('div');
        div.className = 'show-item';

        let metaBits = [];
        if (genres.length) metaBits.push(genres.join(', '));
        if (tags.length) metaBits.push(tags.slice(0, 3).join(', '));
        const metaText = metaBits.length ? ` – ${metaBits.join(' · ')}` : '';

        if (selectionMode === "genre") {
          div.innerHTML = `
            <span>${show.name}</span>
            <small>${metaText}</small>
          `;
        } else {
          div.innerHTML = `
            <input type="checkbox" id="${id}" data-show-id="${show.id}">
            <label for="${id}">${show.name}</label>
            <small>${metaText}</small>
          `;
        }

        showListEl.appendChild(div);
      });
    }

    function onSelectionModeChange(fromAuto = false) {
      if (selectionMode === "genre") {
        if (!genresAvailable) {
          selectionMode = "show";
          const showRadio = document.querySelector('input[name="selectionMode"][value="show"]');
          if (showRadio) showRadio.checked = true;
          modeHelpEl.textContent = "Show mode is active because this JSON doesn't have usable genres. Pick shows directly.";
        } else {
          modeHelpEl.textContent = "Genre mode is active: select one or more genres. All shows in those genres will be used.";
        }
        genreListEl.classList.toggle("disabled", !genresAvailable);
      } else {
        modeHelpEl.textContent = "Show mode is active: genres are ignored. Pick your shows directly.";
      }

      renderShowList();
      currentPlaylist = [];
      renderPlaylist([], 0);
      statusEl.textContent = fromAuto ? '' : 'Selection mode changed.';
    }

    function getSelectedShowIds() {
      if (selectionMode === "genre") {
        const shows = getShowsMatchingSelectedGenres();
        return shows.map(s => s.id);
      } else {
        const checked = showListEl.querySelectorAll('input[type="checkbox"]:checked');
        return Array.from(checked).map(cb => cb.getAttribute('data-show-id'));
      }
    }

    function renderPlaylist(list, totalSeconds) {
      if (!list || !list.length) {
        playlistContainer.innerHTML = '<div class="small">No playlist generated yet.</div>';
        summaryEl.textContent = '';
        return;
      }
      const totalH = totalSeconds > 0 ? (totalSeconds / 3600).toFixed(2) : '–';
      let summaryText = `Episodes: ${list.length}`;
      if (totalSeconds > 0) {
        summaryText += ` • Approx duration: ${totalH} hours (target ~11h50m)`;
      } else {
        summaryText += ` • Approx 12-hour set (no duration data, using episode count).`;
      }
      summaryEl.textContent = summaryText;

      let html = '<table>';
      html += '<thead><tr><th>#</th><th>Show</th><th>Title</th><th>Duration</th></tr></thead><tbody>';
      list.forEach((ep, idx) => {
        html += `<tr data-index="${idx}" draggable="true">
          <td>${idx + 1}</td>
          <td>${ep.showName}</td>
          <td>${ep.title}</td>
          <td>${formatDuration(ep.durationSeconds)}</td>
        </tr>`;
      });
      html += '</tbody></table>';
      playlistContainer.innerHTML = html;

      attachDragAndDropHandlers();
    }

    function attachDragAndDropHandlers() {
      const rows = playlistContainer.querySelectorAll('tr[data-index]');
      let dragSrcIndex = null;

      rows.forEach(row => {
        row.addEventListener('dragstart', (e) => {
          dragSrcIndex = parseInt(row.getAttribute('data-index'), 10);
          e.dataTransfer.effectAllowed = 'move';
        });

        row.addEventListener('dragover', (e) => {
          e.preventDefault();
          row.classList.add('drag-over');
          e.dataTransfer.dropEffect = 'move';
        });

        row.addEventListener('dragleave', () => {
          row.classList.remove('drag-over');
        });

        row.addEventListener('drop', (e) => {
          e.preventDefault();
          row.classList.remove('drag-over');
          const targetIndex = parseInt(row.getAttribute('data-index'), 10);
          if (dragSrcIndex === null || targetIndex === dragSrcIndex) return;
          const moved = currentPlaylist.splice(dragSrcIndex, 1)[0];
          currentPlaylist.splice(targetIndex, 0, moved);
          const totalSeconds = sumDurations(currentPlaylist);
          renderPlaylist(currentPlaylist, totalSeconds);
        });
      });
    }

    buildBtn.addEventListener('click', () => {
      submitStatusEl.textContent = '';
      submitStatusEl.className = 'small';

      const listener = listenerNameInput.value.trim();
      const title = streamTitleInput.value.trim();
      const selectedShowIds = getSelectedShowIds();

      if (!listener) {
        statusEl.className = 'error';
        statusEl.textContent = 'Please enter your listener name.';
        return;
      }
      if (!title) {
        statusEl.className = 'error';
        statusEl.textContent = 'Please enter a desired stream title.';
        return;
      }
      if (!selectedShowIds.length) {
        statusEl.className = 'error';
        statusEl.textContent = selectionMode === "genre"
          ? 'Please select at least one genre (or leave genres blank to use all shows).'
          : 'Please select at least one show.';
        return;
      }

      statusEl.className = 'small';
      statusEl.textContent = 'Building playlist…';

      const selectedShows = allShows.filter(s => selectedShowIds.includes(s.id));

      const grouped = selectedShows.map(show => {
        let list = (show.episodes || [])
          .map(ep => ({
            showId: show.id,
            showName: show.name,
            title: ep.title,
            url: ep.url,
            durationSeconds: typeof ep.durationSeconds === 'number' ? ep.durationSeconds : null
          }))
          .filter(ep => ep.url && !isMultiPartTitle(ep.title));

        list = shuffleArray(list);
        return list;
      });

      const totalAvailableEpisodes = grouped.reduce((acc, g) => acc + g.length, 0);
      if (totalAvailableEpisodes === 0) {
        statusEl.className = 'error';
        statusEl.textContent = 'No eligible episodes found for the chosen selection.';
        return;
      }

      const hasDurations = grouped.some(g => g.some(ep => ep.durationSeconds));
      let resultList, totalSeconds;

      if (hasDurations) {
        const result = buildAlternatingByDuration(grouped, MAX_SECONDS);
        resultList = result.list;
        totalSeconds = result.totalSeconds;
      } else {
        const approxCount = 24;
        resultList = buildAlternatingByCount(grouped, approxCount);
        totalSeconds = sumDurations(resultList);
      }

      currentPlaylist = resultList.slice();
      renderPlaylist(currentPlaylist, totalSeconds);

      statusEl.className = 'success';
      statusEl.textContent = `Playlist created with ${currentPlaylist.length} episodes. You can drag rows to adjust the order.`;
    });

    clearBtn.addEventListener('click', () => {
      currentPlaylist = [];
      renderPlaylist([], 0);
      statusEl.className = 'small';
      statusEl.textContent = 'Playlist cleared.';
      submitStatusEl.textContent = '';
      submitStatusEl.className = 'small';
    });

    sendBtn.addEventListener('click', async () => {
      submitStatusEl.className = 'small';
      submitStatusEl.textContent = '';

      const listener = listenerNameInput.value.trim();
      const title = streamTitleInput.value.trim();
      const bg = getBackgroundChoice();

      if (!listener || !title) {
        submitStatusEl.className = 'error';
        submitStatusEl.textContent = 'Please enter your name and desired stream title before sending.';
        return;
      }
      if (!currentPlaylist || !currentPlaylist.length) {
        submitStatusEl.className = 'error';
        submitStatusEl.textContent = 'Please generate a playlist before sending.';
        return;
      }

      if (!FORMSPREE_ENDPOINT) {
        submitStatusEl.className = 'error';
        submitStatusEl.textContent = 'Formspree endpoint is not configured.';
        return;
      }

      const payload = {
        listener,
        streamTitle: title,
        selectionMode,
        backgroundStyle: bg,
        episodeCount: currentPlaylist.length,
        playlist: currentPlaylist.map((ep, idx) => ({
          index: idx + 1,
          show: ep.showName,
          title: ep.title,
          url: ep.url,
          durationSeconds: ep.durationSeconds || null
        }))
      };

      submitStatusEl.textContent = 'Sending playlist…';

      try {
        const res = await fetch(FORMSPREE_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          throw new Error('Non-200 response from Formspree');
        }

        submitStatusEl.className = 'success';
        submitStatusEl.textContent = 'Playlist sent successfully. Thank you!';
      } catch (err) {
        console.error(err);
        submitStatusEl.className = 'error';
        submitStatusEl.textContent = 'There was a problem sending the playlist. Please try again later.';
      }
    });

    loadShows();
  </script>
</body>
</html>
